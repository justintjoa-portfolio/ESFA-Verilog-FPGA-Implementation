/*---------------------------------------------------------------------------*
 *                   (C) Copyright 2021 by Elmar Grom
 *
 *                           - All Rights Reserved -
 *
 *                  THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE
 *
 * This copyright notice does not evidence any actual or intended publication
 *---------------------------------------------------------------------------*/
/** @file
 *
 * Receiver component of the UART module.
 *
 * The receiver is more complex than the transmitter. Principally it consists
 * of a shift register to collect the transmitted data bits and a state machine
 * to control the overall operation of the receiver. A 4:1 clock divider, edge
 * detector and a bit counter complete the set of functional components.
 *
 * The edge detector senses any falling edge on the rx line, by generating a
 * one clock wide pulse. If the state machine is idle (in state 0) it is started
 * by the appearance of such a pulse. At any other time they are ignored.
 *
 * A falling edge on the rx line indicates the start of a transmission, but new
 * state of the line does not yet represent data. The initial bit time is
 * provided as a means to synchronize the receiver. Thus the state machine has
 * to delay sampling until about the middle if the next bit time has been
 * reached, before taking the first data sample. Note that the delay in starting
 * the sample clock needs to be taken into account in generating this delay. The
 * delay is achieved by simply moving through a sequence of states at the input
 * clock rate.
 *
 * Once sampling has started it proceeds automatically, controlled by the sample
 * clock. Note, that the sample clock is not simply 1/4 of the input clock. By
 * starting it based on the negative edge on the rx line, it is optimally
 * aligned with the data signal. This is important, since the transmission is
 * not in any way synchronized with the local clock. A continuously running
 * clock at the correct bit rate would not work, as it might happen to be
 * maximally misaligned at times, making correct data sampling impossible. The
 * relatively small variations generated by the granularity of the input clock
 * is small enough as to be of no consequence.
 *
 * The bit counter is used to track the completion of data sampling. Once 8 bits
 * have been sampled, the state machine takes over the process once again. It
 * signals the arrival of data and becomes ready to receive the next byte. In
 * case of a data overrun the output data remains unchanged, while the new data
 * byte is lost. This continues to be the case until the receipt of data has
 * been acknowledged.
 *
 * @author  Elmar Grom
 * @date    11/13/2021
 */ /*-----------------------------------------------------------------------*/


module UARTReceiver (input  wire        clock,          // the receive clock prepared by the baud rate generator (4 clocks per bit)
                     input  wire        reset,          // module reset
                     input  wire        rx,             // the receive line
                     input  wire        clearDR,        // 1 transition clears `dataReceived`

                     output wire [7:0]  data,           // the received data
                     output wire        dataReceived,   // 1 indicates a data byte has been received
                     output wire        dataOverrun);   // 1 indicates a data byte has been received while the previous
                                                        // had not been acknowledged

  // --------------------------------------------------------------------------
  // Registers
  // --------------------------------------------------------------------------
  reg [7:0]       register;                             // shift register for receiving data
  reg [7:0]       buffer;                               // holds the received data
  reg [1:0]       edgeDetect;                           // used to detect changes in the input signal level
  reg [2:0]       state;                                // the state of the control state machine

  reg [1:0]       divider;                              // used by the 4:1 clock divider
  reg [3:0]       dataCounter;                          // used to count the data bits

  reg [1:0]       dataState;                            // flags used to indicate state of the data, such as when we are
                                                        // shifting, reception complete, data overrun

  // --------------------------------------------------------------------------
  // Signals
  // --------------------------------------------------------------------------
  wire            smapleClock;
  wire            rxFalling;

  // --------------------------------------------------------------------------
  // Combinatorial logic / Wiring
  // --------------------------------------------------------------------------
  assign data         = buffer;
  assign rxFalling    = (edgeDetect [1] == 1'b1) && (edgeDetect [0] == 1'b0);
  assign smapleClock  = divider [1];
  assign dataReceived = dataState [0];
  assign dataOverrun  = dataState [1];

  // --------------------------------------------------------------------------
  // Sequential logic
  // --------------------------------------------------------------------------

  // --------------------------------------------------------
  // 4:1 clock divider, using a two stage toggle FF
  // --------------------------------------------------------
  // This brings the supplied clock down to the correct sample
  // rate for the input signal. This clock only runs while we
  // are shifting data into the shift register. By starting it
  // with the `shift` signal, it is brought into the proper
  // phase relationship with the data signal.
  // --------------------------------------------------------
/*
  always @ (posedge clock)
  begin
    if (state == 3'h0)
    begin
      divider     <= 2'h0;
    end

    else
    begin
      divider [0] <= !divider [0];
    end
  end

  always @ (posedge divider [0])
  begin
    divider [1]   <= !divider [1];
  end
*/

  always @ (posedge clock)
  begin
    if (reset == 1'b0)
    begin
      divider         <= 2'h0;
    end

    else
    begin
      case (divider)
        2'h0 :
          begin
            divider   <= 2'h1;
          end

        2'h1 :
          begin
            if (state != 3'h0)
            begin
              divider <= 2'h2;
            end
          end

        2'h2 :
          begin
            divider   <= 2'h3;
          end

        2'h3 :
          begin
            divider   <= 2'h0;
          end

      endcase
    end
  end

  // --------------------------------------------------------
  // Data bit counting and sampling
  // --------------------------------------------------------
  always @ (posedge smapleClock)
  begin
    if (state == 3'h5)
    begin
      dataCounter   <= dataCounter + 4'h1;    // count the bit
      register      <= {rx, register [7:1]};  // sample the data bit
    end

    else
    begin
      dataCounter   <= 4'h0;                  // keep counter in reset
    end
  end

  // --------------------------------------------------------
  // Edge detection support on the rx line
  // --------------------------------------------------------
  always @ (posedge clock)
  begin
    if (reset == 1'b0)
    begin
      edgeDetect      <= 2'h0;
    end

    else
    begin
      edgeDetect [0]  <= rx;
      edgeDetect [1]  <= edgeDetect [0];
    end
  end

  // --------------------------------------------------------
  // Data state handling
  // --------------------------------------------------------
  always @ (negedge clock)
  begin
    if (reset == 1'b0)                    // reset
    begin
      dataState [0]   <= 1'b0;
      dataState [1]   <= 1'b0;
    end

    else
    begin
      if (clearDR == 1'b1)                // clear data flags
      begin
        dataState [0] <= 1'b0;
        dataState [1] <= 1'b0;
      end

      else if (state == 3'h6)
      begin
        dataState [0] <= 1'b1;            // flag data ready
      end

      else if (state == 3'h7)
      begin
        dataState [1] <= 1'b1;            // flag data overrun
      end
    end
  end


  // --------------------------------------------------------
  // The state machine
  // --------------------------------------------------------
  always @ (posedge clock)
  begin
    if (reset == 1'b0)                    // reset
    begin
      state           <= 3'h0;
      buffer          <= 8'h00;
    end

    else
    begin
      case (state)                        // state machine
        3'h0 :
          begin
            if (rxFalling == 1'b1)        // start of transmission detected
            begin
              state   <= 3'h1;            // +
            end                           // |
          end                             // |
                                          // |
        3'h1 :                            //
          begin                           // delay to cover the start bit
            begin                         //
              state   <= 3'h2;            // |
            end                           // |
          end                             // |
                                          // |
        3'h2 :                            // |
          begin                           // |
            begin                         // |
              state   <= 3'h3;            // |
            end                           // |
          end                             // |
                                          // |
        3'h3 :                            // |
          begin                           // |
            begin                         // |
              state   <= 3'h4;            // |
            end                           // |
          end                             // |
                                          // V
        3'h4 :                            // +
          begin
            begin
              state         <= 3'h5;
            end
          end

        3'h5 :
          begin
            if (dataCounter == 4'h8)
            begin
              if (dataState [0] == 1'b1)  // data ready flag has not yet been cleared (data overrun)
              begin
                state         <= 3'h7;    // ready to go again
              end

              else
              begin
                buffer        <= register;// copy sampled data to buffer
                state         <= 3'h6;
              end
            end
          end

        3'h6 :
          begin
            state             <= 3'h0;    // ready to go again
          end

        3'h7 :
          begin
            state             <= 3'h0;    // ready to go again
          end
      endcase
    end
  end

endmodule
// ----------------------------------------------------------------------------
